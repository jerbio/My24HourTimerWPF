using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace My24HourTimerWPF
{
    class SnugArray
    {
        TimeSpanWithID[] TopElements;
        SnugArray[] SubSnugArrayElements;
        List<Dictionary<string, int>> ListOfDictionaryOfID_Count;//This is a List of Dictionaries with a string of ID and a count of the IDs found
        List<string> AlreadyFoundPermutation;
        List<TimeSpanWithID> ConstainedElements;
        Dictionary<string, List<TimeSpanWithID>> ParentID_TimeSpanID;
//        public bool NotValid;

        public SnugArray()
        {
            /*This works recursively. This works by generating a list of elements that can fit within the Timespan to be snugly fit
             Each element in the aforementioned creates a copy of the timespan and then subtracts itself from the copy of the timespan.
             Then a new snug array List is created with the rest of the elements of the array and the remaining time.
             */

        }


        public SnugArray(List<TimeSpanWithID> ConstrainedElements, List<TimeSpanWithID> EntryArrayOfStuff, TimeSpan MaxValue)
        {
            EntryArrayOfStuff=EntryArrayOfStuff.OrderBy(obj=>obj.TimeSpanID.ToString()).ToList();
            ParentID_TimeSpanID = new Dictionary<string,List<TimeSpanWithID>>();
            foreach (TimeSpanWithID MyTimeSpanWithID in EntryArrayOfStuff)
            {
                string ParentCharString=MyTimeSpanWithID.TimeSpanID.getCalendarEventID();
                if(ParentID_TimeSpanID.ContainsKey(ParentCharString ))
                {
                    
                    ParentID_TimeSpanID[MyTimeSpanWithID.TimeSpanID.getCalendarEventID()].Add(MyTimeSpanWithID);
                }
                else
                {
                    ParentID_TimeSpanID.Add(ParentCharString,new List<TimeSpanWithID>());
                    ParentID_TimeSpanID[ParentCharString].Add(MyTimeSpanWithID);
                }
            }

            

            SnugArray MyThis = new SnugArray(ConstrainedElements, EntryArrayOfStuff, MaxValue, new Dictionary<string, int>(), new List<Dictionary<string, int>>());
            


            TopElements=MyThis.TopElements;
            SubSnugArrayElements=MyThis.SubSnugArrayElements;
            ListOfDictionaryOfID_Count=MyThis.ListOfDictionaryOfID_Count;//This is a List of Dictionaries with a string of ID and a count of the IDs found
            AlreadyFoundPermutation=MyThis.AlreadyFoundPermutation;
            ConstainedElements=MyThis.ConstainedElements;
        }

        private SnugArray(List<TimeSpanWithID> ConstrainedElements,List<TimeSpanWithID> EntryArrayOfStuff, TimeSpan MaxValue,Dictionary<string, int> MyDict,List<Dictionary<string, int>> MyListOfDicts)
        {
            int i = 0;
            this.ConstainedElements = new List<TimeSpanWithID>();
            int j=0;
            for (;j<ConstrainedElements.Count;j++)
            {
                
                TimeSpanWithID myConstrainedSubCalEvent=ConstrainedElements[j];
                ConstrainedElements.Remove(myConstrainedSubCalEvent);
                --j;
                this.ConstainedElements.Add(myConstrainedSubCalEvent);
                MaxValue=MaxValue - myConstrainedSubCalEvent.timeSpan;
                i=0;
                for (; i < EntryArrayOfStuff.Count; i++)
                {
                    if (EntryArrayOfStuff[i].TimeSpanID.ToString() == myConstrainedSubCalEvent.TimeSpanID.ToString())
                    {
                        EntryArrayOfStuff.RemoveAt(i);
                        if (MyDict.ContainsKey(myConstrainedSubCalEvent.TimeSpanID.getCalendarEventID()))
                        {

                            ++(MyDict[myConstrainedSubCalEvent.TimeSpanID.getCalendarEventID()]);
                        }
                        else
                        {

                            MyDict.Add(myConstrainedSubCalEvent.TimeSpanID.getCalendarEventID(), 1);
                        }

                        break;
                    }
                }
            }

            


            List<TimeSpanWithID> SmallerElements = new List<TimeSpanWithID>();
            i = 0;
            int MyArrayCount = EntryArrayOfStuff.Count;
            ListOfDictionaryOfID_Count = MyListOfDicts;
            for (; i < MyArrayCount; i++)//loop gets element only smaller or equal to max size
            {
                if (EntryArrayOfStuff[i].timeSpan <= MaxValue)//checks if smaller than max value
                {
                    SmallerElements.Add(EntryArrayOfStuff[i]);
                    
                }
            }
            
            TopElements = SmallerElements.ToArray();
            int LengthOfSubElmentArray = TopElements.Length;
            SubSnugArrayElements = new SnugArray[LengthOfSubElmentArray];

            i = 0;

            TimeSpanWithID[] MyFittableElemtsHolder = new TimeSpanWithID[SmallerElements.Count];//Array holds the current array of subelements for future reasons
            List<TimeSpanWithID> MyFittableElementsHolderList = new List<TimeSpanWithID>();//This is also holds a curent array of sub elements.
            SmallerElements.CopyTo(MyFittableElemtsHolder, 0);
            MyFittableElementsHolderList = MyFittableElemtsHolder.ToList();
            MyArrayCount = SmallerElements.Count;
             
            for (; i < MyArrayCount; i++)
            {
                Dictionary<string, int> MyDictCpy = new Dictionary<string, int>(MyDict);
                MyFittableElementsHolderList.Remove(TopElements[i]);//removes a value that meets criteria of less than max value. This is used to form a node. The sub nodes will be have only values less than or equal to Max Value-other elements
                EventID TimeSpanID = TopElements[i].TimeSpanID;
                if (TimeSpanID.ToString() == "134_142_183")
                {
                    ;
                }
                if (CheckIfNewIdCansSpinNewTree(MyDictCpy, TimeSpanID.getCalendarEventID()))
                {
                    if (MyDictCpy.ContainsKey(TimeSpanID.getCalendarEventID()))
                    {

                        ++(MyDictCpy[TopElements[i].TimeSpanID.getCalendarEventID()]); 
                    }
                    else
                    {

                        MyDictCpy.Add(TimeSpanID.getCalendarEventID(), 1); 
                    }
                    //ListOfDictionaryOfID_Count.Add(MyDict);
                    SubSnugArrayElements[i] = new SnugArray(ConstrainedElements,MyFittableElementsHolderList, (MaxValue - TopElements[i].timeSpan), MyDictCpy, ListOfDictionaryOfID_Count);//creates new snug array with elements that are smaller
                }
                else
                {
                    List<TimeSpanWithID> Temp_TopElements = TopElements.ToList();
                    Temp_TopElements.Remove(TopElements[i]);
                    TopElements = Temp_TopElements.ToArray();
                    
                    SnugArray[] TempCopy_SubSnugArrayElements = new SnugArray[--LengthOfSubElmentArray];
                    MyArrayCount = LengthOfSubElmentArray;
                    
                    Array.Copy(SubSnugArrayElements, 0, TempCopy_SubSnugArrayElements, 0, i);
                    --i;
                    
                    SubSnugArrayElements = TempCopy_SubSnugArrayElements;
                    /*ListOfDictionaryOfID_Count.Add(MyDict);
                    SubSnugArrayElements[i] = new SnugArray(new List<TimeSpanWithID>(),new TimeSpan(0));*/
                }
                SmallerElements.CopyTo(MyFittableElemtsHolder, 0);
                MyFittableElementsHolderList = MyFittableElemtsHolder.ToList();
            }

            if (i == 0)//this checks to see if there were no additional subelements created by checking the index counter of the preceeding for loop
            {
                if (!DoIExist(MyDict))
                {
                    ListOfDictionaryOfID_Count.Add(new Dictionary<string, int>(MyDict));
                }
            }
        
        }

        bool CheckIfNewIdCansSpinNewTree(Dictionary<string, int> MyDict, string ID)
        {
            if (MyDict.ContainsKey(ID))
            {
                ++(MyDict[ID]);
                if(DoIExist(MyDict))
                {
                    --MyDict[ID];
                    return false;
                }
                else
                {
                    --MyDict[ID];
                    return true;
                }
            }
            else 
            {
                return true;
            }
        }



        
        
        //Dictionary<string , Tuple<List<Dictionary>,List<TimeSpanWithID>>>


        private bool DoIExist(Dictionary<string, int> MyDict)
        {
            string[] DetectedID = MyDict.Keys.ToArray();
            bool retValue = false;

            List<Dictionary<string, int>> PertinentDicts = new List<Dictionary<string, int>>();

            foreach (Dictionary<string, int> PossibleMatchinDict in ListOfDictionaryOfID_Count)
            {
                if (PossibleMatchinDict.Keys.Count >= MyDict.Keys.Count)
                {
                    foreach (string IDKEY in MyDict.Keys)
                    {
                        if (PossibleMatchinDict.ContainsKey(IDKEY))
                        {
                            if (MyDict[IDKEY] <= PossibleMatchinDict[IDKEY])
                            {
                                retValue = true;
                            }
                            else
                            {
                                retValue = false;
                                break;
                            }
                        }
                        else
                        {
                            retValue = false;
                            break;
                        }
                    }

                    if (retValue)
                    {
                        return retValue;
                    }
                    
                    //PertinentDicts.Add(PossibleMatchinDict);
                }
            }

            /*foreach (Dictionary<string, int> PossibleMatchInDict in PertinentDicts)// this will only work for a scenario where we are trying to build the tightest schedule
            {
                foreach (string IDKEY in MyDict.Keys)
                {
                    if (PossibleMatchInDict.ContainsKey(IDKEY))
                    {
                        if (MyDict[IDKEY] == PossibleMatchInDict[IDKEY])
                        {
                            retValue = true;
                        }
                        else
                        {
                            retValue = false;
                            break;
                        }
                    }
                    else
                    {
                        retValue = false;
                        break;
                    }
                }

                if (retValue)
                {
                    return retValue;
                }
            }*/


            return retValue;
        }

        List<List<TimeSpanWithID>> GenerateSnugPossibilities(string MyID)
        {
            //List<string> MyFoundID = MyID.Split('#').ToList();

            List<List<TimeSpanWithID>> JustAllSubPossibilities;
            int i = 0;
            List<TimeSpanWithID> MyCurrentList = new List<TimeSpanWithID>();
            int j = 0;
            JustAllSubPossibilities = new List<List<TimeSpanWithID>>();
            List<List<TimeSpanWithID>> MyTotalSubPossibilities = new List<List<TimeSpanWithID>>(); ;
            for (; i < TopElements.Length; i++)
            {
                MyCurrentList.Add(TopElements[i]);

                JustAllSubPossibilities = SubSnugArrayElements[i].GenerateSnugPossibilities(MyID);
                //JustAllSubPossibilities.Add(MyCurrentList);
                j = 0;
                for (; j < JustAllSubPossibilities.Count; j++)
                {
                    JustAllSubPossibilities[j].Add(TopElements[i]);
                    JustAllSubPossibilities[j].AddRange(ConstainedElements);
                }
                if (JustAllSubPossibilities.Count == 0)
                {
                    JustAllSubPossibilities.Add(MyCurrentList);

                }
                MyCurrentList = new List<TimeSpanWithID>();
                MyTotalSubPossibilities = MyTotalSubPossibilities.Concat(JustAllSubPossibilities).ToList();
            }
            return MyTotalSubPossibilities;
        }

        public List<List<TimeSpanWithID>> MySnugPossibleEntries
        {
            get
            {
                List<List<TimeSpanWithID>> reValue = new List<List<TimeSpanWithID>>();
                
                foreach (Dictionary<string, int> mySnugDictionary in ListOfDictionaryOfID_Count)
                {
                    List<string> DictionaryKeys = mySnugDictionary.Keys.ToList();
                    List<TimeSpanWithID> FullTImeLine = new List<TimeSpanWithID>();

                    foreach (string ParentID_Matched in DictionaryKeys)
                    {
                        int CountMax = mySnugDictionary[ParentID_Matched];
                        int i = 0;
                        for (; i < CountMax; i++)
                        {
                            FullTImeLine.Add(ParentID_TimeSpanID[ParentID_Matched][i]);
                        }
                    }
                    reValue.Add(FullTImeLine);
                }


                return reValue;
                
                
                
                /*
                List<List<TimeSpanWithID>> JustAllSubPossibilities;
                int i = 0;
                List<TimeSpanWithID> MyCurrentList = new List<TimeSpanWithID>();
                int j = 0;
                JustAllSubPossibilities = new List<List<TimeSpanWithID>>();
                List<List<TimeSpanWithID>> MyTotalSubPossibilities = new List<List<TimeSpanWithID>>(); ;
                for (; i < TopElements.Length; i++)
                {
                    MyCurrentList.Add(TopElements[i]);
                    
                    JustAllSubPossibilities = SubSnugArrayElements[i].MySnugPossibleEntries;
                    j = 0;
                    for (; j < JustAllSubPossibilities.Count; j++)
                    {
                        JustAllSubPossibilities[j].Add(TopElements[i]);
                        JustAllSubPossibilities[j].AddRange(ConstainedElements);    
                    }
                    if (JustAllSubPossibilities.Count == 0)
                    {
                        JustAllSubPossibilities.Add(MyCurrentList);
                    }
                    MyCurrentList = new List<TimeSpanWithID>();
                    MyTotalSubPossibilities = MyTotalSubPossibilities.Concat(JustAllSubPossibilities).ToList();
                }
                return MyTotalSubPossibilities;*/
            }
        }

        public TimeSpanWithID[] MyTopElements
        {
            get
            {
                return TopElements;
            }
        }
    }

}
